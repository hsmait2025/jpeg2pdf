<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Merge, Compress & Split PDF</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#007bff">
  <style>
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:0; padding:1rem; background:#f7f9fb; color:#111; }
    .container { max-width:720px; margin:0 auto; background:#fff; padding:1rem; border-radius:8px; box-shadow:0 6px 20px rgba(10,20,30,0.06); }
    h2 { margin:0 0 1rem; text-align:center; font-size:1.25rem; }
    .controls { display:flex; flex-direction:column; gap:0.75rem; }
    label { display:flex; gap:0.5rem; align-items:center; font-size:0.95rem; }
    input[type=file] { padding:0.25rem 0; }
    button { background:#0b74ff; color:#fff; border:none; padding:0.8rem; border-radius:6px; font-size:1rem; cursor:pointer; }
    button:active { transform:translateY(1px); }
    #fileList { margin-top:1rem; padding-left:1rem; font-size:0.92rem; }
    .preview { display:flex; flex-wrap:wrap; gap:8px; margin-top:0.8rem; justify-content:center; }
    .preview-item { position:relative; width:48%; border-radius:6px; border:1px solid #e6e9ee; background:#f9f9f9; transition:transform 0.2s ease, box-shadow 0.2s ease; }
    .preview-item.dragging { opacity:0.5; transform:scale(1.05); box-shadow:0 4px 12px rgba(0,0,0,0.15); }
    .preview img, .preview canvas { width:100%; border-radius:6px; object-fit:cover; }
    .label-number { position:absolute; top:5px; left:5px; background:rgba(0,0,0,0.6); color:#fff; padding:2px 5px; font-size:14px; border-radius:4px; }
    .delete-btn { position:absolute; top:5px; right:5px; background:rgba(255,0,0,0.8); color:#fff; padding:2px 6px; font-size:12px; border-radius:4px; cursor:pointer; }
    @media(min-width:600px){ .preview-item { width:23%; } }
    .note { margin-top:0.6rem; font-size:0.85rem; color:#555; }
    .split-section { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #ddd; }
  </style>

  <!-- PDF.js for rendering PDF previews -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
  </script>

</head>
<body>
  <div class="container">
    <h2>Merge & Compress — JPG / PNG / PDF → Single PDF</h2>

    <div class="controls">
      <label><input id="combineAll" type="checkbox" /> Combine ALL uploads into a single PDF</label>
      <label><input id="showSize" type="checkbox" /> Show size info after processing</label>
      <input id="files" type="file" accept=".jpeg,.jpg,.png,.pdf" multiple />
      <button id="startBtn">Process & Download</button>
    </div>

    <div class="note">Upload JPG / PNG / PDF. If "Combine" is checked, all uploads are merged in uploaded order into one PDF.</div>

    <ul id="fileList"></ul>
    <div class="preview" id="preview"></div>

    <!-- PDF Splitter Section -->
    <div class="split-section">
      <h2>PDF Splitter — Split PDF into Single Pages</h2>
      <div class="controls">
        <input id="splitFile" type="file" accept=".pdf" />
        <button id="splitBtn">Split PDF</button>
      </div>
      <div class="note">Upload a PDF and split it into separate single-page PDFs.</div>
    </div>
  </div>

  <!-- pdf-lib -->
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>

  <script>
  (function(){
    const fileInput = document.getElementById('files');
    const fileListEl = document.getElementById('fileList');
    const previewEl = document.getElementById('preview');
    const combineCheckbox = document.getElementById('combineAll');
    const showSizeCheckbox = document.getElementById('showSize');
    const startBtn = document.getElementById('startBtn');
    const splitInput = document.getElementById('splitFile');
    const splitBtn = document.getElementById('splitBtn');
    const TARGET_BYTES = 200 * 1024; // 200KB
    const mmToPt = mm => mm * 72 / 25.4;
    const A4_W = mmToPt(210), A4_H = mmToPt(297), MARGIN_PT = mmToPt(10);
    let selectedFiles = [];

    fileInput.addEventListener('change', () => {
      selectedFiles = Array.from(fileInput.files).sort((a,b)=>a.lastModified - b.lastModified);
      renderPreview();
    });

    function renderPreview() {
      previewEl.innerHTML = '';
      fileListEl.innerHTML = '';

      selectedFiles.forEach((f, index) => {
        const li = document.createElement('li');
        li.textContent = `${index + 1}. ${f.name}`;
        fileListEl.appendChild(li);

        const wrapper = document.createElement('div');
        wrapper.className = 'preview-item';
        wrapper.draggable = true;
        wrapper.dataset.index = index;

        wrapper.addEventListener('dragstart', e => {
          e.dataTransfer.setData('text/plain', index);
          wrapper.classList.add('dragging');
        });
        wrapper.addEventListener('dragend', () => wrapper.classList.remove('dragging'));
        wrapper.addEventListener('dragover', e => { e.preventDefault(); wrapper.style.outline = '2px dashed #007bff'; });
        wrapper.addEventListener('dragleave', () => wrapper.style.outline = '');
        wrapper.addEventListener('drop', e => {
          e.preventDefault(); wrapper.style.outline = '';
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          const toIndex = parseInt(wrapper.dataset.index);
          if (fromIndex !== toIndex) {
            const movedItem = selectedFiles.splice(fromIndex, 1)[0];
            selectedFiles.splice(toIndex, 0, movedItem);
            renderPreview();
          }
        });

        const label = document.createElement('div');
        label.className = 'label-number';
        label.textContent = index + 1;

        const delBtn = document.createElement('div');
        delBtn.className = 'delete-btn';
        delBtn.textContent = '❌';
        delBtn.onclick = () => { selectedFiles.splice(index, 1); renderPreview(); };

        if (f.type.startsWith('image/')) {
          const img = document.createElement('img');
          img.src = URL.createObjectURL(f);
          img.onload = () => URL.revokeObjectURL(img.src);
          wrapper.appendChild(img);
        } else if (/\.pdf$/i.test(f.name)) {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const reader = new FileReader();
          reader.onload = async () => {
            try {
              const typedarray = new Uint8Array(reader.result);
              const pdf = await pdfjsLib.getDocument(typedarray).promise;
              const page = await pdf.getPage(1);
              const viewport = page.getViewport({ scale: 0.4 });
              canvas.height = viewport.height;
              canvas.width = viewport.width;
              await page.render({ canvasContext: ctx, viewport }).promise;
            } catch (err) { console.error("PDF preview error:", err); }
          };
          reader.readAsArrayBuffer(f);
          wrapper.appendChild(canvas);
        }

        wrapper.appendChild(label);
        wrapper.appendChild(delBtn);
        previewEl.appendChild(wrapper);
      });
    }

    async function compressImageToJpegUint8(file, targetBytes = TARGET_BYTES) {
      const img = await loadHTMLImageFromFile(file);
      let canvas = document.createElement('canvas');
      let ctx = canvas.getContext('2d');
      canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
      ctx.drawImage(img, 0, 0);
      let quality = 0.92, minQuality = 0.18, minDim = 200, u8, size;
      while (true) {
        const dataUrl = canvas.toDataURL('image/jpeg', quality);
        u8 = dataURLToUint8Array(dataUrl); size = u8.length;
        if (size <= targetBytes || (quality <= minQuality && (canvas.width <= minDim || canvas.height <= minDim))) break;
        if (quality > 0.25) { quality = Math.max(minQuality, quality - 0.15); continue; }
        const newW = Math.round(canvas.width * 0.85), newH = Math.round(canvas.height * 0.85);
        if (newW < minDim || newH < minDim) break;
        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = newW; tmpCanvas.height = newH;
        tmpCanvas.getContext('2d').drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, newW, newH);
        canvas = tmpCanvas; ctx = tmpCanvas.getContext('2d');
        quality = Math.max(minQuality, 0.85);
      }
      return { bytes: u8, width: canvas.width, height: canvas.height, size };
    }

    function dataURLToUint8Array(dataURL) {
      const base64 = dataURL.split(',')[1];
      const binary = atob(base64); const arr = new Uint8Array(binary.length);
      for (let i=0;i<binary.length;i++) arr[i] = binary.charCodeAt(i);
      return arr;
    }

    function loadHTMLImageFromFile(file) {
      return new Promise((res, rej) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { URL.revokeObjectURL(url); res(img); };
        img.onerror = rej; img.src = url;
      });
    }

    function readFileAsArrayBuffer(file) {
      return new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = () => res(r.result); r.onerror = rej;
        r.readAsArrayBuffer(file);
      });
    }

    function drawImageOnPage(pdfDoc, page, embeddedImage, imgPxW, imgPxH) {
      const ptsPerPx = 72 / 96;
      const imgWPt = imgPxW * ptsPerPx, imgHPt = imgPxH * ptsPerPx;
      const maxW = A4_W - 2*MARGIN_PT, maxH = A4_H - 2*MARGIN_PT;
      const scale = Math.min(1, maxW / imgWPt, maxH / imgHPt);
      const drawW = imgWPt * scale, drawH = imgHPt * scale;
      const x = (A4_W - drawW) / 2, y = (A4_H - drawH) / 2;
      page.drawImage(embeddedImage, { x, y, width: drawW, height: drawH });
    }

    async function mergeAllFiles() {
      const pdfDoc = await PDFLib.PDFDocument.create();
      let totalOriginalSize = 0;
      for (const f of selectedFiles) {
        totalOriginalSize += f.size;
        if (/\.(jpe?g|png)$/i.test(f.name)) {
          const compressed = await compressImageToJpegUint8(f, TARGET_BYTES);
          const embedded = await pdfDoc.embedJpg(compressed.bytes.buffer);
          const page = pdfDoc.addPage([A4_W, A4_H]);
          drawImageOnPage(pdfDoc, page, embedded, compressed.width, compressed.height);
        } else if (/\.pdf$/i.test(f.name)) {
          const arr = await readFileAsArrayBuffer(f);
          const srcPdf = await PDFLib.PDFDocument.load(arr);
          const copied = await pdfDoc.copyPages(srcPdf, srcPdf.getPageIndices());
          copied.forEach(p => pdfDoc.addPage(p));
        }
      }
      const mergedBytes = await pdfDoc.save();
      downloadBlob(new Blob([mergedBytes], { type: 'application/pdf' }), 'merged.pdf');
    }

    function downloadBlob(blob, name) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = name;
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 5000);
    }

    startBtn.addEventListener('click', async () => {
      if (!selectedFiles.length) return alert('Please choose files first');
      startBtn.disabled = true; startBtn.textContent = 'Processing...';
      try {
        if (combineCheckbox.checked) await mergeAllFiles();
        else for (const f of selectedFiles) await processSingleFile(f);
      } catch (err) { alert('Error: ' + err.message); }
      startBtn.disabled = false; startBtn.textContent = 'Process & Download';
    });

    async function processSingleFile(file) {
      if (/\.(jpe?g|png)$/i.test(file.name)) {
        const pdfDoc = await PDFLib.PDFDocument.create();
        const compressed = await compressImageToJpegUint8(file, TARGET_BYTES);
        const embedded = await pdfDoc.embedJpg(compressed.bytes.buffer);
        const page = pdfDoc.addPage([A4_W, A4_H]);
        drawImageOnPage(pdfDoc, page, embedded, compressed.width, compressed.height);
        downloadBlob(new Blob([await pdfDoc.save()], { type: 'application/pdf' }), file.name.replace(/\.[^/.]+$/, '') + '_compressed.pdf');
      } else if (/\.pdf$/i.test(file.name)) {
        const arr = await readFileAsArrayBuffer(file);
        const srcPdf = await PDFLib.PDFDocument.load(arr);
        const dest = await PDFLib.PDFDocument.create();
        const copied = await dest.copyPages(srcPdf, srcPdf.getPageIndices());
        copied.forEach(p => dest.addPage(p));
        downloadBlob(new Blob([await dest.save()], { type: 'application/pdf' }), file.name.replace(/\.[^/.]+$/, '') + '_compressed.pdf');
      }
    }

    splitBtn.addEventListener('click', async () => {
      const file = splitInput.files[0];
      if (!file) return alert('Please select a PDF to split');
      try {
        const arr = await readFileAsArrayBuffer(file);
        const srcPdf = await PDFLib.PDFDocument.load(arr);
        for (let i=0; i<srcPdf.getPageCount(); i++) {
          const newPdf = await PDFLib.PDFDocument.create();
          const [copiedPage] = await newPdf.copyPages(srcPdf, [i]);
          newPdf.addPage(copiedPage);
          downloadBlob(new Blob([await newPdf.save()], { type: 'application/pdf' }), `${file.name.replace(/\.pdf$/i, '')}_page${i+1}.pdf`);
        }
      } catch (err) { alert('Error splitting PDF: ' + err.message); }
    });

  })();
  </script>
<script>
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("service-worker.js")
      .then(() => console.log("Service Worker Registered"));
  }
</script>
</body>
</html>
